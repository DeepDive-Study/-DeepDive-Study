# 2주차

### CH 10 ,11

10.1 객체란 ?

- 자바스크립트는 객체 기반의 프로그래밍 언어  
→ 원시값을 제외한 나머지 값 (함수 , 배열 , 정규 표현식 등) 모두 객체
- 원시 타입은 단 하나의 값만 나타냄 
ex ) 3, test
- 객체타입은 다양한 앖을 하나의 단위로 구성한 복합적인 자료구조
- 원시 타입 = `변경 불가능`  객체타입 = `변경 가능`
- 객체는 0개 이상의 프로퍼티로 구성 된 집합 
프로퍼티 : 키와 값으로 구성

```jsx
var person = {
	name : 'lee',
	age : 20
}
```

- 네이밍 규칙
    - -  쓰지말기
    - obj[key] = ‘world’ 처럼 쓰기 가능
    - 빈문자열 가능 → 기능은 없음
    - 키는 보통 문자열로 인식

10.4 메서드 

- js에서 사용할 수 있는 모든 값을 프로퍼티 값으로 사용 가능
- 함수도 동일함 → 구분을 위해 메서드라고 부름

10.5 프로퍼티 접근

- 마침표 표기
- 대괄호 표기 → 프로퍼티키를 따옴표로 감싸야함

10.8 프로퍼티 삭제 

- delete 연산자를 사용
    
    delete person.age 
    

10.9 es6확장 기능 

```
// ES5
var x = 1, y = 2;

var obj = {
  x: x,
  y: y
};

console.log(obj); // {x: 1, y: 2}
```

```
// ES6
let x = 1, y = 2;

// 프로퍼티 축약 표현
const obj = { x, y };

console.log(obj); // {x: 1, y: 2}
```

→ 변수이름과 프로퍼티 키가 동일한 이름일 때 키 생략 가능 

리터럴 내부에서 계산된 값으로 프로퍼티 이름 동적 생성이 가능해짐 

```
// ES6
const prefix = 'prop';
let i = 0;

// 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i
};

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

프로퍼티 안에서 function 키워드 생략 가능 

```
// ES6
const obj = {
  name: 'Lee',
  // 메서드 축약 표현
  sayHi() {
    console.log('Hi! ' + this.name);
  }
};

obj.sayHi(); // Hi! Lee
```

---

### 11장 원시 값과 객체의 비교

원시 타입 값 

- 변수 할당시 메모리에 실제 값이 저장
- 값에 의한 전달
- 값 변경 불가

객체 타입 값

- 변수 할당시 참조값이 저장
- 참조에 의한 전달
- 값이 변경 가능

11.1 원시값 

- 변경 불가해서 한 번 생성되면 읽기 전용이라 값 변경 불가
- 변수 : 값을 저장하기 위해 확보하 메모리 공간 식별을 위해 붙인 값
- 값 : 변수에 저장된 데이터 ← 요게 변경이 불가  변수값 자체는 재할당 통해서 변경 가능 그러니까 값이 변하는 값 변수다

```
// const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 상수는 재할당이 금지된 변수일 뿐이다.
const o = {};

// const 키워드를 사용해 선언한 변수에 할당한 원시값(상수)은 변경할 수 없다.
// 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있다.
o.a = 1;
console.log(o); // {a: 1}
```

11.1.2 문자열과 불변성 

- 문자열 원시값
- 0개 이상의 문자로 이루어진 집합
- 1개의 문자는 2바이트 메모리 공간에 저장  문자열은 길이에 따라 메모리 공간 크기도 다름 //  숫자는 그냥 동일함 바이트
- 유사 배열객체이며 이터러블이므로 배열과 유사하게 문자에 접근이 가능

```
var str = 'string';

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
console.log(str[0]); // s

// 원시 값인 문자열이 객체처럼 동작한다.
console.log(str.length); // 6
console.log(str.toUpperCase()); // STRING
```

```
var str = 'string';

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
// 하지만 문자열은 원시값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
str[0] = 'S';

console.log(str); // string
```

→ 원시값이니까 자체 변경은 불가함 

11.1.3 값에 의한 전달 

```
var score = 80;

// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy); // 80  80
console.log(score === copy); // true
```

같긴 해도 두 변수가 가리키고 있는 메모리는 다름 값만 같은 거 

두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되기 때문에 재할당으로 값을 변경해도 서로 간섭이 일어나지 않아서 같지 않아짐 

11.2 객체 

- 프로퍼티 갯수가 정해저 있지 않음
- 동적 추가 및 삭제 가능
- 프로퍼티 값에 제한 없고 이 때문에 메모리 공간 크기를 사전에 정할 수 없음
- 객체 관리를 프로퍼티 키를 인덱스로 사용하는 해시 테이블 같은 느낌으로 관리한다

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20a1794a8193484c698cf095f2c2ae6fdb/Untitled.png)

- 자바 같은 객체지향 프로그래밍 언어는 사전에 정의된 클래스 기반으로 객체를 생성하기에 이미 생성전부터 프로퍼티 메서드가 정해져서 생성 이후 프로퍼티 삭제및 구가가 불가… 자바스크립트는 클래스 없이 객체생성이 가능하기에 객체가 만들어진 이후에도 동적으로 프로퍼티와 메서드 추가 가능
- 진짜 생각해보면 자바는 객체만들고 new로 만들어서 쓰는데 자바스크립트 쓰면서 객체 만들어서 써야지라고 생각한 적 없는듯

11.2.1 변경 가능한 값 

- 객체타입은 변경가능함
- 원시값은 변수가 메모리 주소로 메모리 값에 접근하니까 값 자체를 값으로 가짐
- 객체 할당 변수는 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근 참조값에 접근함

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20a1794a8193484c698cf095f2c2ae6fdb/Untitled%201.png)

```
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다.
var person = {
  name: 'Lee'
};

// person 변수에 저장되어 있는 참조값으로 실제 객체에 접근해서 그 객체를 반환한다.
console.log(person); // {name: "Lee"}
```

→ 먼지 모르겠지만 원시값이랑 참조값은 메모리 저장방식이 변수에 할당되는 방식과 근본적으로 다르다고 함 

```
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
};

console.log(person1 === person2); // ①  거짓 -> 참조 메모리 주소 다름 
console.log(person1.name === person2.name); // ② 참 원시값 같음 
```

---

12.1 함수란 ? 

- 함수 : 일련의 과정을 문으로 구현하고 코드 불록으로 감싸서 하나의 실행 단위로 정의

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20a1794a8193484c698cf095f2c2ae6fdb/Untitled%202.png)

12.2 함수 사용 이유 

- 코드의 재사용
- 유지보수 편의성을 높임

12.3 함수 리터럴 

- 함수는 객체타입의 값
- 리터럴은 프로그램에 의해 직접 표현 되는 고정된 값 ex) 숫자 , 문자열 ㅡ 불리언 , 배열 ,객체
- 일반 객체는 호출 못하지만 함수는 호출 가능

```
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};

```

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20a1794a8193484c698cf095f2c2ae6fdb/Untitled%203.png)

함수 선언문은 함수 이름 생략 불가 

```
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.
var add = function add(x, y) {
  return x + y;
};

// 함수 호출
console.log(add(2, 5)); // 7
```

→ 자바스크립트 엔진이 객체리터럴로 해석해서 동작가능 

```
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
// 그룹 연산자의 피연산자는 값으로 표현되어야하기에 표현식이 아닌 문인 함수 선언문은 피연산자로 사용불가 
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined
```

![Untitled](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20a1794a8193484c698cf095f2c2ae6fdb/Untitled%204.png)

자바스크립트 엔진에서 생성된 함수 호출을 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 함수 객체를 할당했음 

함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출 

```
var add = function add(x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
```

선언문으로 만들어두면 암묵적으로 식별자 할당해두나보군 

12.4.2 함수표현식 

- 함수는 객체 타입의 값
- 변수 할당 가능 - 프로퍼티 값 , 변수 , 배열 요소 등등
- 일급 객체 - 값의 성질을 가진다 = 값처럼 자유롭게 사용

```
// 기명 함수 표현식
var add = function foo (x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5)); // 7

// 함수 이름으로 호출하면 ReferenceError가 발생한다.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.
console.log(foo(2, 5)); // ReferenceError: foo is not defined

```

화살표 함수 

- 항상 익명 함수로 정의

```
// 화살표 함수
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

인수 확인 

- 자바 스크립트 함수는 매개변수와 인수의 갯수가 일치하는지 확인하지않는다
- 매개변수 타입을 사전에 지정 불가

```
function add(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    // 매개변수를 통해 전달된 인수의 타입이 부적절한 경우 에러를 발생시킨다.
    throw new TypeError('인수는 모두 숫자 값이어야 합니다.');
  }

  return x + y;
}

console.log(add(2));        // TypeError: 인수는 모두 숫자 값이어야 합니다.
console.log(add('a', 'b')); // TypeError: 인수는 모두 숫자 값이어야 합니다.
```

즉시 실행 함수 

- 한 번만 호출 되며 다시 호출 불가
- () 로 감싸야함

```
// 익명 즉시 실행 함수
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}());
```

재귀 함수 

- 함수가 자기 자신을 호출
- 무한 반복에 빠질 수 있으므로 주의 필요

```
function countdown(n) {
  if (n < 0) return;
  console.log(n);
  countdown(n - 1); // 재귀 호출
}

countdown(10);
```

콜백 함수 

- 반복하는 일은 공통 수행하면서 일부분만 다른 경우 공통 로직을 미리 정해두고 경우에 따라 추가 기능을 수행하도록 함
- 매개변수를 통해 다른 함수의 내부로 전달 되는 함수를 콜백

```
// 외부에서 전달받은 f를 n만큼 반복 호출한다.
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i); // i를 전달하면서 f를 호출
  }
}

var logAll = function (i) {
  console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logAll); // 0 1 2 3 4

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logOdds); // 1 3
```

#