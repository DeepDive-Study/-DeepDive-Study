# 14. 전역 변수의 문제점

## 14.1 변수의 생명 주기

### 지역 변수의 생명 주기

변수는 선언에 의해 생성되고 할당을 통해 값을 얻은 후 쓸모를 다하면 소멸하는 생명주기가 있다.

지역 변수는 함수가 호출되면 함수 몸체의 코드가 순차 실행되기 이전 선언되고, 함수가 종료하면 소멸된다. 즉 지역 변수의 생명주기는 함수의 생명 주기와 일치한다.

단, 지역 변수가 함수보다 오래 생존하는 경우도 있다. 변수가 등록된 스코프가 메모리에 할당된 후 가비지 콜렉터에 의해 해제되기 전까지 유효하기 때문에 스코프가 참조되고 있다면 소멸하지 않는다. (클로저 관련)

### 전역 변수의 생명주기

함수와 달리 전역 코드는 전역 객체(코드 실행 이전 자바스크립트 엔진에서 제일 먼저 생성되는 특수한 객체. 브라우저에서는 window, Node.js에서는 global 등)의 프로퍼티가 된다.

명시적 호출 없이 곧바로 실행되고 마지막 문이 실행된 후 종료된다. 즉 전역 변수의 생명주기는 전역 객체의 생명주기와 일치한다.

## 14.2 전역 변수의 문제점

암묵적 결합: 모든 코드가 전역 변수를 참조하고 변경할 수 있어 가독성이 나빠지고 의도치 않은 변경이 일어날 수 있다.

긴 생명 주기: 생명 주기가 길어서 메모리 리소스를 오래 소비한다.

스코프 체인 상에서 종점에 존재: 전역 변수가 가장 마지막에 검색되므로 검색 속도가 느리다.

네임스페이스 오염: 자바스크립트는 파일이 분리되어도 하나의 전역 스코프를 공유하기 때문에 다른 파일의 변수명과 중복될 가능성이 있다.

## 14.3 전역 변수의 사용을 억제하는 방법

전역 변수를 반드시 사용해야 할 이유가 없다면 지역 변수를 사용해야 한다.

### 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

### 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성한 후 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가한다. 단, 이 객체 자체는 전역 변수에 할당되므로 책에서는 유용한 것 같지 않다고 설명한다.

### 모듈 패턴

클래스를 모방하여 즉시 실행 함수로 감싸 하나의 모듈을 만드는 방식이다. 클로저를 기반으로 동작하며, 캡슐화(프로퍼티와 메서드를 하나로 묶는 것. 정보 은닉 목적으로 사용한다)까지 구현할 수 있다.

대부분의 객체지향 언어는 클래스 구성 멤버에 대해 public, private, protected등의 접근 제한자를 사용할 수 있는데, 자바스크립트에서는 제공하지 않는다. 모듈 패턴을 사용하면 반환하는 객체 프로퍼티를 퍼블릭, 반환하지 않는 객체 프로퍼티를 프라이빗 멤버로 사용할 수 있다.

### ES6 모듈

script 태그에 type='module' 속성이 있는 자바스크립트 파일은 모듈로써 동작한다. (모던 브라우저에서 사용할 수 있고 구형 브라우저에서는 동작하지 않음)

ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공하므로 전역 변수를 사용할 수 없게 된다.

# 15. let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

- 중복 선언 : 값까지 할당했다면 먼저 선언된 값이 변경되어 의도치 않은 부작용이 발생할 수 있다.
- 함수 레벨 스코프: 함수의 코드 블록만을 지역 변수로 인정하므로 함수 외부에서 var 키워드로 선언한 변수는 if문이나 for문 등의 코드 블록 내라도 모두 전역 변수가 된다.
- 변수 호이스팅: var 키워드는 런타임 이전에 선언 단계와 초기화 단계가 한번에 진행된다. 즉 변수 호이스팅에 의해 스코프에 변수가 초기화된 상태로 존재하기 때문에 변수 선언문 이전에 참조할 수 있어서(할당문이 없다면 undefined) 가독성이 떨어지고 오류를 발생시킬 가능성이 생긴다.

## 15.2 let 키워드

ES6에서 var 키워드의 단점을 보완하기 위해 새로운 변수 선언 키워드인 let과 const를 도입했다.

- 변수 중복 선언 금지: 중복 선언하면 문법 에러가 발생한다.
- 블록 레벨 스코프: 모든 코드 블록을 지역 스코프로 인정한다.
- 변수 호이스팅: 호이스팅은 발생하지만 선언 단계와 초기화 단계가 분리되어 진행된다. 초기화 단계가 변수 선언문에 도달했을 때 실행되므로 그 전에 변수에 접근하면 참조 에러가 발생한다. (스코프 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대, TDZ라고 한다)

브라우저 환경에서 var키워드로 선언한 전역 변수와 전역 함수, 암묵적 전역은 전역 객체 window의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.

let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 보이지 않는 개념적인 블록인 전역 렉시컬 환경의 선언적 환경 레코드 내에 존재하게 된다.

## 15.3 const 키워드

const 키워드는 대부분의 경우 상수를 선언할 때 사용한다. let 키워드와 대부분 동일하지만, 다른 점이 몇 가지 있다.

- 선언과 초기화: 블록 스코프를 가지며, 선언과 동시에 초기화하지 않으면 문법 에러가 발생한다.
- 재할당 금지: var, let 키워드와 달리 재할당이 금지된다.
- 상수: 원시 값을 할당할 경우 변수 값을 변경할 수 없다(재할당 없이 값을 변경할 수 있는 방법이 없으므로). 이러한 특징을 이용해 const 키워드를 상수 표현에 사용한다.

상수를 적극적으로 사용해 유지보수성과 가독성을 높이는 것이 좋다. 또한 일반적으로 상수는 대문자로 선언해 상수임을 명확히 나타낸다.

단, 객체를 할당할 경우 참조 타입이므로 재할당 없이도 값 변경이 가능하다. 상수는 불변이 아니다.

+덧붙이자면 리액트와 같은 라이브러리에서는 const가 가진 특징과 참조 타입 객체의 비교가 컴포넌트 업데이트의 중요한 부분으로 작용한다.

## 15.4 var vs. let vs. const

변수 선언 시 기본적으로 const를 사용하고 let은 재할당이 필요한 경우 사용하는 것이 좋다. 의도치 않은 재할당을 안전하게 방지하는 것이 좋기 때문이다.

- ES6라면 var 키워드를 사용하지 않는다
- 재할당이 필요한 경우에만 let 키워드를 사용하고, 변수 스코프를 최대한 좁게 만든다.
- 변경이 발생하지 않는 원시 값과 객체에는 const를 사용한다.
