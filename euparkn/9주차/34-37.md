# 이터러블

## 이터레이션 프로토콜

ES6에서 도입되었다. 순회 가능한 자료구조를 만들기 위해 ECMA사양에 정의한 규칙이다.

ES6 이전의 배열, 문자열, 유사 배열 객체 등은 통일된 규약 없이 다양한 방법으로 순회 가능했으나, ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일했다.

이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있다.

- 이터러블 프로토콜: `Symbol.iterator`를 프로퍼티 키로 사용한 메서드를 호출하면 이터레이터를 반환한다. 이터러블 프로토콜을 준수한 객체를 이터러블이라고 하며, for…of문으로 순회할 수 있고 스프레드 문법과 배열 디스트럭처링 할당(구조 분해 할당)의 대상으로 사용할 수 있다.
- 이터레이터 프로토콜: 이터러블의 `Symbol.iterator` 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이터는 next 메서드를 소유하며, next 메서드를 호출하면 이터러블을 순회하면서 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. 이터레이터 프로토콜을 준수한 이터레이터를 이터레이터라고 하며 이터러블의 요소를 탐색하기 위한 포인터 역할을 한다.

## 빌트인 이터러블

표준 빌트인 객체 중 Array, String, Map, Set, TypedArray, arguments, DOM 컬렉션은 빌트인 이터러블이다.

## for … 문

이터러블을 순회하면서 요소를 변수에 할당한다.

```jsx
for (변수선언문 of 이터러블) {
}
```

for … in 문과 형태는 유사하지만 for … of 문은 내부적으로 이터레이터의 next 메서드를 호출하여 순회한다(이터레이터 리절트 객체의 done 프로퍼티가 true일 때까지).

## 이터러블과 유사 배열 객체

유사 배열 객체는 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체이다. arguments, NodeList 등의 유사 배열 객체이면서 이터러블인 객체도 있지만 모든 유사 배열 객체가 이터러블인 것은 아니다.

## 사용자 정의 이터러블

이터레이션 프로토콜을 준수하지 않는 일반 객체도 이터레이션 프로토콜을 준수하도록 구현하면 사용자 정의 이터러블이 된다.

```jsx
const fibonacci = {
  [Symbol.iterator]() {
    let [pre, cur] = [0, 1];
    const max = 10;

    return {
      next() {
        [pre, cur] = [cur, pre + cur];
        return { value: cur, done: cur >= max };
      },
    };
  },
};
```

# 스프레드 문법

ES6에서 도입되었으며, for … of 문으로 순회할 수 있는 이터러블에 한정해 사용할 수 있다.

```jsx
console.log(...[1, 2, 3]); // 1 2 3
console.log(..."hello"); // h e l l o
```

스프레드 문법의 결과는 값이 아니므로 변수에 할당할 수 없다. 다음과 같이쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다.

- 함수 호출문의 인수 목록
- 배열 리터럴 내부
  - concat, splice 메서드 대신 사용하여 배열을 결합하고 조작할 수 있다.
  - 얕은 복사에 사용할 수 있다.
  - 이터러블을 배열로 변환할 때 사용할 수 있다.
- 객체 리터럴 내부
  - 스프레드 문법의 대상은 이터러블이어야 하지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 사용을 허용한다. (이전에는 Object.assign 메서드로 객체를 조작했다)
  ```jsx
  const sample = { ...{ x: 1, y: 2 }, ...{ y: 5, z: 3 } }; // { x: 1, y: 5, z: 3 }
  ```

# 디스트럭처링 할당 (구조 분해 할당)

구조화된 배열과 같은 이터러블 또는 객체를 destructuring(비구조화)하여 1개 이상의 변수에 개별적으로 할당하는 것이다. 이터러블 또는 객체에서 필요한 값만 추출하여 변수에 할당할 때 유용하다.

변수의 개수와 이터러블 또는 객체의 요소 개수가 반드시 일치할 필요는 없다.

```jsx
// 배열
// 배열 디스트럭처링 할당의 대상은 이터러블이어야 하며 인덱스 순서대로 할당된다.
var arr = [1, 2, 3];
var one = arr[0];

const [x, y = 0] = [1, 2]; // ES6
```

```jsx
// 객체
// 객체 디스트럭처링 할당 기준은 프로퍼티 키다.
var obj = { x: 1, y: 2 };
var first = obj.x;

const { x, y } = obj; // ES6
```

```jsx
// Rest 프로퍼티를 사용할 수 있으며 Rest 요소와 마찬가지로 반드시 마지막에 위치해야 한다.
const { x, ...rest } = { x: 1, y: 2 };
```

# Set

Set 객체는 중복되지 않는 유일한 값들의 집합이다. 수학적 집합을 구현하기 위한 자료구조이므로 교집합, 합집합, 차집합, 여집합 등을 구현할 수 있다.

| 구분               | 배열 | Set 객체 |
| ------------------ | ---- | -------- |
| 동일 값 중복 가능  | O    | X        |
| 순서에 의미가 있음 | O    | X        |
| 인덱스로 요소 접근 | O    | X        |

- 자바스크립트의 모든 값을 요소로 저장할 수 있다.
- Set 생성자 함수로 생성하며, 이터러블이다.
- 이터러블을 인수로 전달받을 수 있고, 전달하지 않으면 빈 Set 객체가 생성된다.
- 메서드
  - Set.prototype.size: 요소 개수 확인
  - Set.prototype.add: 요소 추가(중복이면 무시됨)
  - Set.prototype.has: 요소 존재 여부 확인
  - Set.prototype.delete: 요소 삭제
  - Set.prototype.clear: 요소 일괄 삭제
  - Set.prototype.forEach: 요소 순회(이 경우 다른 이터러블 순회와 호환성을 갖기 위해 요소가 추가된 순서를 따른다)

```jsx
const set = new Set([1, 2, 3, 3]); // Set(3) {1, 2, 3}
// 중복된 값은 저장되지 않는다
```

# Map

Map 객체는 키와 값의 쌍으로 이루어진 컬렉션이다.

| 구분                   | 객체                    | Map 객체              |
| ---------------------- | ----------------------- | --------------------- |
| 키로 사용할 수 있는 값 | 문자열 or 심벌          | 객체를 포함한 모든 값 |
| 이터러블               | X                       | O                     |
| 요소 개수 확인         | Object.keys(obj).length | map.size              |

- Map 생성자 함수로 생성하며, 이터러블이다.
- 키와 값의 쌍으로 이루어진 이터러블을 인수로 전달받고, 전달하지 않으면 빈 Map 객체가 생성된다.
- 메서드
  - Map.prototype.size: 요소 개수 확인 (getter만 존재)
  - Map.prototype.set: 요소 추가(중복이면 덮어씀). 요소가 추가된 Map 객체를 반환하므로 연속 호출 가능하다.
  - Map.prototype.has: 요소 존재 여부 확인
  - Map.prototype.get: 특정 요소 취득
  - Map.prototype.delete: 요소 삭제
  - Map.prototype.clear: 요소 일괄 삭제
  - Map.prototype.forEach: 요소 순회(이 경우 다른 이터러블 순회와 호환성을 갖기 위해 요소가 추가된 순서를 따른다)
    - forEach 메서드의 콜백 함수 내부에서 this로 사용될 객체를 3개의 인수로 전달한다. (현재 순회중인 요소값, 현재 순회중인 요소의 키, 현재 순회중인 Map 객체 자체)

```jsx
const map = new Map([
  ["k1", "v1"],
  ["k2", "v2"],
]); // Map(2) {"k1" => "v1", "k2" => "v2"}
// 중복된 값은 덮어쓴다
```
