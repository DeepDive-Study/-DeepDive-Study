# JS 스터디

Created time: 2023년 10월 31일 오후 1:29
날짜: 2023년 10월 31일

## 4장. 변수

---

### 4.1 변수란 무엇인가? 왜 필요한가?

---

-   변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 또한 값의 위치를 가리키는 상징적인 이름이다.
-   메모리는 데이터를 저장할 수 있는 메모리 셀의 집합이다. 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽어 들인다
-   각 셀은 고유의 메모리 주소를 갖는다. 이 메모리 주소는 메모리 공간의 위치를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표현된다.
-   컴퓨터는 모든 데이터를 2진수로 처리한다.
-   프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 매커니즘을 제공한다.
-   **Keyword**
    -   **`변수명(변수 이름)`** : 메모리 공간에서 저장된 값을 식별할 수 있는 고유한 이름
    -   **`변수 값`** : 변수에 저장된 값
    -   **`할당`** : 변수에 값을 저장하는 것
    -   **`참조`** : 변수에 저장된 값을 읽어들이는 것

![스크린샷 2023-10-31 오후 10.41.37.png](JS%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%207179bf775fa74c30bc7c373c52811ecf/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.41.37.png)

### 4.2 식별자

---

-   식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.
-   식별자는 값이 아니라 메모리 주소를 기억하고 있다.
-   4-1의 위 사진 참고

(중요. let과 const의 차이 ⇒ 추후 링크 연결하기)

### 4.3 변수 선언

---

-   변수를 사용하려면 반드시 선언이 필요하다.
-   변수를 선언할 때는 var, let, const 키워드를 사용한다.
-   변수 선언에 의해 확보된 메모리 공간은 비어 있을 것 같지만, 확보된 메모리 공간에는 JS 엔진에 의해 undefined 라는 값이 암묵적으로 할당되어 초기화 된다.
-   변수는 `var`, `let`, `const` 키워드를 사용하여 **선언**하고 할당 연산자를 사용해 값을 **할당**한다. 그리고 식별자인 변수명을 사용해 변수에 저장된 값을 **참조**한다.
-   변수 선언단계
    1. 선언단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
    2. 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화 한다.
    ![스크린샷 2023-10-31 오후 10.41.48.png](JS%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%207179bf775fa74c30bc7c373c52811ecf/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-10-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.41.48.png)

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

---

-   변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 한다
-   var, let, const, function, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅 된다.
-   모든 선언문은 런타임(소스코드가 한 줄씩 순차적으로 실행되는 시점) 이전 단계에서 먼저 실행되기 때문이다.

```jsx
4-5 예제코드

console.log(score); // undefined // Reference Error가 발생하지 않는다

var score; // 변수 선언문
```

(포이마웹 2.3 변수 호이스팅 부분 참고해서 내용 더 보충하면 좋을듯)

### 4.5 값의 할당

---

-   할당 연산자 =는 우변의 값을 좌변의 변수에 할당한다

```jsx
var score = 100; // 변수 선언과 값의 할당
```

-   변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

![Untitled](JS%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%207179bf775fa74c30bc7c373c52811ecf/Untitled.png)

### 4.6 값의 재할당

---

-   재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.

```jsx
var score = 80;
score = 90;
```

-   값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수(constant)라 한다. (추후에 나오는 const에서 자세히 다룸)
-   undefined와 80은 어떤 변수도 값으로 갖고 있지않다. 다시 말해 어떤 식별자와도 연결되어 있지 않다.
-   **가비지콜렉터**
    -   애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능
    -   더 이상 사용되지 않는 메모리 == 어떤 식별자도 참조하지 않는 메모리 공간
    -   자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어
        [가비지 컬렉션](https://ko.javascript.info/garbage-collection)

**언매니지드 언어와 매니지드 언어**

-   언매니지드 언어는 메모리 제어를 개발자가 주도할 수 있다.
-   따라서 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만 반대로 치명적 오류를 생산할 가능성도 있다.
-   매니지드 언어는 메모리 관리 기능을 언어 차원에서 담당하과 개발자의 직접적인 메모리 제어를 허용하지 않는다.
-   더 이상 사용하지 않는 메모리의 해제는 가비지 콜렉터가 수행하며, 이 또한 개발자가 관여할 수 없다.
-   개발자의 역량의 의존하는 부분이 작아져 생산성을 확보할 수 있지만, 성능 면에서 어느 정도의 손실은 감수할 수 밖에 없다.

### 4.7 식별자 네이밍 규칙

---

-   예약어목록 ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#keywords](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#keywords))
-   변수 규칙

*   라틴문자(0-9, a-z, A-Z,), \_
*   대소문자를 구분함
*   한국어 ❌
*   예약어 ❌
*   숫자로 시작 ❌
*   특수문자 ❌ (\_, $ 두가지는 예외)
*   이모지 ❌
*   여러개의 변수를 1, 2, 3 숫자로 구분 ❌ -> 최대한 의미있게, 구체적인 이름으로 작성

-   좋은코드와 나쁜코드

```jsx
// Good
age;
myAge;
init;
initialColor;
finalOutputValue;
backgroundAudio;

// Bad
1;
a;
_12;
myage;
MYAGE;
var Document;
skjfndskjfnbdskjfb;
thisisareallylongstupidvariablenameman;
```

-   자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다.

```jsx
// camelCase
var firstName;

// PascalCase
var LastName;
```

## 5장. 표현식과 문

---

### 5.1 값

---

-   값(value)은 식(표현식 expression)이 평가(evalutate)되어 생성된 결과를 말한다.
-   변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 실벽하기 위해 붙인 이름이라 고했다. 따라서 변수에 할당되는 것은 값이다.

```jsx
// 변수에 10 +20이 평가되어 생성된 숫자 값 30이 할당된다.
var sum = 10 + 20;
```

### 5.2 리터럴

---

-   리터럴은 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.
-   리터럴 종류 ([https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Grammar_and_types#리터럴](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Grammar_and_types#%EB%A6%AC%ED%84%B0%EB%9F%B4))

### 5.3 표현식

---

-   표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참고한다.
-   표현식은 리터럴, 식별자, 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다. 이러한 표현식은 값으로 평가된다는 점에서 모두 동일하며, 값으로 평가될 수 있는 문은 모두 표현식이다.

```jsx
// 리터럴 표현시
10;
("Hello");

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum;
person.name;
arr[1];

// 연산자 표현식
10 + 20;
sum = 10;
sum !== 10;

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square();
person.getName();
```

### 5.4 문

---

-   문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위다
-   문은 여러 토큰으로 구성된다. 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.
-   문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

```jsx
// 변수 선언문
var x;

// 할당문
x = 5;

// 함수 선언문
function foo() {}

// 조건문
if (x > 1) {
    console.log(x);
}

// 반복문
for (var i = 0; i < 2; i++) {
    console.log(i);
}
```

### 5.5 세미콜론과 세미콜론 자동 삽입 기능

---

-   문의 끝에 붙이는 세미콜론은 옵션이며 생략 가능하다.
-   자바스크립트 엔진이 소스코드를 해석할때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI : automatic semicolon insertion)이 암묵적으로 수행되기 때문이다.

### 5.6 표현식인 문과 표현식이 아닌 문

---

-   둘을 구분하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.
-   표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다.
-   표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당하면 에러가 발생한다

```jsx
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
var x;
var foo = var x; // Uncaught SyntaxError: Unexpected token 'var'

// 할당문은 그 자체가 표현식이고 완전한 문이다.
x = 100;
var foo = x = 100; // 변수에 할당 가능
console.log(foo); // 100
```

# 6장. 데이터 타입

---

## 6.1 숫자 타입

---

```jsx
// 모두 숫자 타입이다.
var integer = 10; // 정수
var double = 10.12; // 실수
var negative = -20; // 음의 정수

var binary = 0b01000001; // 2진수
var octal = 0o101; // 8진수
var hex = 0x41; // 16진수

// 표기법만 다를 뿐 모두 같은 값이다.
console.log(binary); // 65
console.log(octal); // 65
console.log(hex); // 65
console.log(binary === octal); // true
console.log(octal === hex); // true

// 숫자 타입은 모두 실수로 처리된다.
console.log(1 === 1.0); // true
console.log(4 / 2); // 2
console.log(3 / 2); // 1.5

// 숫자 타입의 세 가지 특별한 값
console.log(10 / 0); // Infinity
console.log(10 / -0); // -Infinity
console.log(1 * "String"); // NaN

// 자바스크립트는 대소문자를 구별한다.
var x = nan; // ReferenceError: nan is not defined
```

## 6.2 문자열 타입

---

```jsx
// 문자열 타입
var string;
string = "문자열"; // 작은따옴표
string = "문자열"; // 큰따옴표
string = `문자열`; // 백틱 (ES6)

string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식된다.';
string = "큰따옴표로 감싼 문자열 내의 '작은따옴표'는 문자열로 인식된다.";

// 따옴표로 감싸지 않은 hello를 식별자로 인식한다.
var string = hello; // ReferenceError: hello is not defined
```

## 6.3 템플릿 리터럴

---

### 6.3.1 멀티라인 문자열

-   일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다.

```jsx
var str = 'Hello
world.';
// SyntaxError: Invalid or unexpected token
```

-   일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 공백도 있는 그대로 적용된다.

```jsx
var template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';

console.log(template);
/*
<ul>
  <li><a href="#">Home</a></li>
</ul>
*/
```

### 6.3.2 표현식 삽입

-   +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

```jsx
var first = "Ung-mo";
var last = "Lee";

// ES5: 문자열 연결
console.log("My name is " + first + " " + last + "."); // My name is Ung-mo Lee.

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}.`); // My name is Ung-mo Lee.

console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3
```

## 6.4 불리언 타입

---

```jsx
var foo = true;
console.log(foo); // true

foo = false;
console.log(foo); // false
```

## 6.5 undefined 타입

---

-   undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.
-   **변수에 값이 없다는 것을 명시하고 싶을 때는 undefined를 할당하는 것이 아니라 null을 할당한다.**

```jsx
var foo;
console.log(foo); // undefined
```

## 6.6 null 타입

---

-   프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다.
-   변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 잇상 참조하지 않겠다는 의미이며, 자바스크립트 엔진은 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다.

```jsx
var foo = "Lee";

// 이전에 할당되어 있던 값에 대한 참조를 제거. foo 변수는 더 이상 'Lee'를 참조하지 않는다.
// 유용해 보이지는 않는다. 변수의 스코프를 좁게 만들어 변수 자체를 재빨리 소멸시키는 편이 낫다.
foo = null;
```

## 6.7 심벌 타입

---

-   심벌은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다.

```jsx
// 심벌 값 생성
var key = Symbol("key");
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = "value";
console.log(obj[key]); // value
```

## 6.8 객체 타입

---

(11장에서 자세히 다룬다.)

-   자바스크립트는 객체 기반의 언어이며, **자바스크립트를 이루고 있는 거의 모든 것이 객체다.**

## 6.9 데이터 타입의 필요성

---

-   데이터 타입은 값의 종류를 말한다.
-   자바스크립트의 모든 값은 데이터 타입을 갖는다.
-   데이터 타입이 필요한 이유는 다음과 같다.
    -   값을 저장할 때 확보해야 하는 **메모리 공간의 크기를 결정**하기 위해
    -   값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
    -   메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해

## 6.10 동적 타이핑

---

### 6.10.1 동적 타입 언어와 정적 타입 언어

-   정적타입 언어
    -   변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.
    -   컴파일시점에 **타입체크**(선언한 데이터 타입에 맞는 값을 할당 했는지 검사하는 처리)를 수행한다.
    -   타입체크를 통과하지 못했다면 에러를 발생시키고 프로그램의 실행 자체를 막는다.
-   자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다.
-   자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.

```jsx
var foo;
console.log(typeof foo); // undefined

foo = 3;
console.log(typeof foo); // number

foo = "Hello";
console.log(typeof foo); // string

foo = true;
console.log(typeof foo); // boolean

foo = null;
console.log(typeof foo); // object --> 그냥 암기하기!!

foo = Symbol(); // 심벌
console.log(typeof foo); // symbol

foo = {}; // 객체
console.log(typeof foo); // object

foo = []; // 배열
console.log(typeof foo); // object

foo = function () {}; // 함수
console.log(typeof foo); // function
```

### 6.10.2 동적 타입 언어와 변수

-   동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다.
-   변수값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다. 또한 변수값의 변경에 의해 타입도 언제든지 변경될 수 있다.
-   따라서 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다.
-   **가독성이 좋은 코드가 좋은 코드다.**
-

# 07장: 연산자

---

## 7.1 산술 연산자

---

### 7.1.1 이항 산술 연산자

```jsx
5 + 2; // -> 7
5 - 2; // -> 3
5 * 2; // -> 10
5 / 2; // -> 2.5
5 % 2; // -> 1
```

### 7.1.2 단항 산술 연산자

```jsx
var x = 1;

// ++ 연산자는 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.
x++; // x = x + 1;
console.log(x); // 2

// -- 연산자는 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.
x--; // x = x - 1;
console.log(x); // 1

//=====
var x = 5,
    result;

// 선할당 후증가(postfix increment operator)
result = x++;
console.log(result, x); // 5 6

// 선증가 후할당(prefix increment operator)
result = ++x;
console.log(result, x); // 7 7

// 선할당 후감소(postfix decrement operator)
result = x--;
console.log(result, x); // 7 6

// 선감소 후할당 (prefix decrement operator)
result = --x;
console.log(result, x); // 5 5

//=====
var x = "1";

// 문자열을 숫자로 타입 변환한다.
console.log(+x); // 1
// 부수 효과는 없다.
console.log(x); // "1"

// 불리언 값을 숫자로 타입 변환한다.
x = true;
console.log(+x); // 1
// 부수 효과는 없다.
console.log(x); // true

// 불리언 값을 숫자로 타입 변환한다.
x = false;
console.log(+x); // 0
// 부수 효과는 없다.
console.log(x); // false

// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
x = "Hello";
console.log(+x); // NaN
// 부수 효과는 없다.
console.log(x); // "Hello"
```

### 7.1.3 문자열 연결 연산자

```jsx
// 문자열 연결 연산자
"1" + 2; // -> '12'
1 + "2"; // -> '12'

// 산술 연산자
1 + 2; // -> 3

// true는 1로 타입 변환된다.
1 + true; // -> 2

// false는 0으로 타입 변환된다.
1 + false; // -> 1

// null은 0으로 타입 변환된다.
1 + null; // -> 1

// undefined는 숫자로 타입 변환되지 않는다.
+undefined; // -> NaN
1 + undefined; // -> NaN
```

## 7.2 할당 연산자

---

```jsx
var x;

x = 10;
console.log(x); // 10

x += 5; // x = x + 5;
console.log(x); // 15

x -= 5; // x = x - 5;
console.log(x); // 10

x *= 5; // x = x * 5;
console.log(x); // 50

x /= 5; // x = x / 5;
console.log(x); // 10

x %= 5; // x = x % 5;
console.log(x); // 0

var str = "My name is ";

// 문자열 연결 연산자
str += "Lee"; // str = str + 'Lee';
console.log(str); // 'My name is Lee'
```

-   할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.

```jsx
var x;

// 할당문은 표현식인 문이다.
console.log((x = 10)); // 10

var a, b, c;

// 연쇄 할당. 오른쪽에서 왼쪽으로 진행.
// ① c = 0 : 0으로 평가된다
// ② b = 0 : 0으로 평가된다
// ③ a = 0 : 0으로 평가된다
a = b = c = 0;

console.log(a, b, c); // 0 0 0
```

## 7.3 비교 연산자

---

-   일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.

```jsx
// 일치 비교
5 === 5; // -> true

// 암묵적 타입 변환을 하지 않고 값을 비교한다.
// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.
5 === "5"; // -> false
```

## 7.4 삼항 조건 연산자

```jsx
var x = 2;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
var result = x % 2 ? '홀수' : '짝수';

console.log(result); // 짝수

//
var x = 2, result;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
if (x % 2) result = '홀수';
else       result = '짝수';

console.log(result); // 짝수

//
var x = 2, result;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
if (x % 2) result = '홀수';
else       result = '짝수';

console.log(result); // 짝수
//var x = 10;

// if...else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.
var result = if (x % 2) { result = '홀수'; } else { result = '짝수'; };
// SyntaxError: Unexpected token if

//var x = 10;

// 삼항 조건 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.
var result = x % 2 ? '홀수' : '짝수';
console.log(result); // 짝수
```

### 7.5 논리 연산자

```jsx
// 논리합(||) 연산자
true || true; // -> true
true || false; // -> true
false || true; // -> true
false || false; // -> false

// 논리곱(&&) 연산자
true && true; // -> true
true && false; // -> false
false && true; // -> false
false && false; // -> false

// 논리 부정(!) 연산자
!true; // -> false
!false; // -> true
```

### 7.6 쉼표 연산자

```jsx
var x, y, z;

(x = 1), (y = 2), (z = 3); // 3
```

### 7.7 그룹 연산자

```jsx
10 * 2 + 3; // -> 23

// 그룹 연산자를 사용하여 우선순위를 조절
10 * (2 + 3); // -> 50
```

### 7.8 typeof 연산자

```jsx
typeof ""; // -> "string"
typeof 1; // -> "number"
typeof NaN; // -> "number"
typeof true; // -> "boolean"
typeof undefined; // -> "undefined"
typeof Symbol(); // -> "symbol"
typeof null; // -> "object"
typeof []; // -> "object"
typeof {}; // -> "object"
typeof new Date(); // -> "object"
typeof /test/gi; // -> "object"
typeof function () {}; // -> "function"
```

### 7.9 지수 연산자

```jsx
Math.pow(2, 2); // -> 4
Math.pow(2, 2.5); // -> 5.65685424949238
Math.pow(2, 0); // -> 1
Math.pow(2, -2); // -> 0.25
```

# 8장.제어문

8,9장 정리후 내용추가 (80% 진행)
